Kotlin in action second edition

* You can see that the name of the class generated by the Kotlin compiler corresponds to the name of the file containing
  the function—capitalized to match Java’s naming scheme and suffixed with Kt.
* @file:JvmName("...") changes default name

```kotlin
package strings
 
fun joinToString( /* ... */ ): String { /* ... */ }
```

to

```kotlin
/* Java */
package strings;
 
public class JoinKt {             
    public static String joinToString(/* ... */) { /* ... */ }
}
```

* Inner and nested classes: Nested by default
  ![img.png](../res/kotlin_inner.png)

//5.1.4 Accessing variables in scope

* The `fold` function is conceptually very similar to `reduce`, but instead of putting the first element of your
  collection
  into the accumulator at the beginning, you can choose an arbitrary start value.

![img.png](../res/kotlin_literals.png)

* Kotlin’s Array class looks like a regular generic class but is compiled to a Java array.
* Arrays of primitive types are represented by special classes, such as IntArray.

* Anonymous functions provide an alternative syntax to lambda expressions with different rules for resolving the return
  expressions. You can use them if you need to write a block of code with multiple exit points.

```kotlin
    //These are the same at bytecode level
    people.forEach(fun(person) {
        if (person.name == "Alice") return
        println("${person.name} is not Alice")
    })

    people.forEach { person ->
        if (person.name == "Alice") return@forEach
        println("${person.name} is not Alice")
    }
```
Cracking the Coding Interview

#### I The interview process

* Focus on Problem-Solving: These interviews assess your ability to tackle new algorithmic problems.
* Limited Time: Expect to delve into one or two questions within a 45-minute timeframe.
* Communication is Crucial: Think out loud and explain your thought process throughout the interview. Interviewers might
  offer hints, which is normal.
* Subjective Evaluation: A numeric score isn't assigned. Instead, interviewers assess your analytical skills, coding
  abilities, technical knowledge, experience, and cultural fit.
* False Negatives are Acceptable: Companies acknowledge that some good candidates might be rejected, but prioritize
  avoiding false positives (hiring unsuitable candidates).
* Problem-Solving Skills Matter: The ability to solve challenging problems with some guidance indicates strong potential
  and intelligence - valuable assets for companies.
* Data Structures & Algorithms: Understanding these fundamentals is beneficial as many interview problems involve them.
  It demonstrates a solid technical foundation.
* Whiteboard Coding: While not reflecting real-world coding scenarios, whiteboards help focus on the core problem
  without getting bogged down in syntax or boilerplate code. It also encourages communication.
* Not a Universal Approach: This interview style may not be suitable for all companies or roles. Some might prioritize
  experience or specific technology expertise.
* Imperfect but Functional: This process has limitations, but it's a common approach. The goal is to optimize your
  performance within this framework.

#### II Behind the scenes

# General Process:

* Phone Screening: Often the first step, involving basic technical questions and assessing your fit for the company.
* On-Site Interviews: Typically consist of 3-6 interviews with engineers, hiring managers, and potentially teammates.
  These interviews cover various areas like coding, algorithms, system design, behavioral questions, and experience.
* Interview Feedback: After the interviews, your interviewers will provide written feedback that is used to make a
  hiring decision.

# Company Specifics:

* Microsoft: Values passionate individuals with strong technical skills. Interviewers may share feedback within the
  team. You might meet the hiring manager if you perform well.
* Amazon: Emphasizes scalability. "Bar Raiser" interviews exist to maintain a high hiring standard. Interviewers don't
  see each other's feedback until submitted.
* Google: Strong focus on analytical abilities and problem-solving skills. Interviewers don't make the final hiring
  decision; a committee reviews feedback and makes a recommendation.
* Apple: Looks for both technical skills and passion for the company and its products. Interviewers typically don't
  share feedback with each other. Final decisions involve directors and VPs.
* Facebook: Uses a role-based interview system with "Jedi" (behavioral), "Ninja" (algorithms/coding), and "Pirate" (
  system design) interviewers. Interviewers submit individual feedback before discussing your performance.
* Palantir: Interviews for specific teams. Phone interviews and coding assessments are common. On-site interviews cover
  experience, domain knowledge, and design. Interviewers discuss feedback with the hiring manager after your visit.

# Tips:

* Be prepared to discuss your passion for the company and the specific role.
* Practice coding on whiteboards and discussing your thought process.
* Tailor your answers to the specific company and role you are interviewing for.
* Follow up with your recruiter if you haven't heard back within a week.

#### III Special situations

* Experienced Candidates: They might be asked similar questions to recent grads, but interviewers might expect them to
  have a deeper understanding of the concepts being tested. Their performance on system design and architecture
  questions will be evaluated with respect to their experience level.
* Testers and SDETs: They should prepare for core testing problems and practice coding questions like regular
  developers. Additionally, they should practice testing the coding problems they solve and demonstrate strong
  communication skills.
* Product (and Program) Managers: Interviewers will assess their skills in handling ambiguity, customer focus (both
  attitude and technical skills), multi-level communication, passion for technology, and teamwork/leadership.
* Dev Lead and Managers: Strong coding skills are required and they will be assessed on teamwork/leadership,
  prioritization, communication, and "getting things done".
* Startups: The application and interview process can be variable. It's important to network and highlight your ability
  to hit the ground running with the specific technologies the startup uses. Interviewers will assess personality fit,
  skill set, and experience.
* Acquisitions and Acquihires: During the technical due diligence process, the acquirer will interview most or all of
  the startup's employees. These interviews are important and can determine which employees receive offers to join the
  acquirer and can affect the acquisition price.
* For Interviewers: The book advises against asking the exact questions in the book and to focus on medium and hard
  problems with multiple hurdles. Interviewers should avoid "scary" questions and offer positive reinforcement to
  candidates. They should also probe deeper on behavioral questions to understand the candidate's role in past
  situations.

#### IV Before the Interview

# Getting the Right Experience (Before you even start applying)

* Students: Take project-heavy classes, get internships (especially early on), or build personal projects to gain
  practical experience. Focus on relevant projects that showcase your coding skills.
* Professionals: If switching to a dream company: try to shift your work responsibilities towards more coding projects.
  If looking to move to a different role (e.g., testing to dev): use your free time to build projects using relevant
  technologies to showcase your skills and initiative.

# Writing a Great Resume

* Highlight your technical skills and coding experience. Less emphasis on non-technical hobbies.
* Length: Keep it concise (ideally 1 page for less than 10 years experience). Recruiters spend limited time reviewing
  resumes, so prioritize the most impressive aspects.
* Employment History: Only include relevant positions that showcase your skills.
* Bullet Points: Use a strong format: "Accomplished X by implementing Y which led to Z." Quantify results whenever
  possible.
* Projects: Highlight 2-4 most significant projects, including details like languages used, whether it was individual or
  team-based, and if completed for a class or independently (independent projects are generally preferred). Don't
  clutter your resume with too many small projects.
* Programming Languages & Software: Be selective about what you list. Consider the company culture and what's most
  relevant to the role. Don't waste space on basic software like MS Office.
* Languages: List most comfortable languages with your proficiency level (e.g., expert, proficient). Avoid listing
  everything you've ever used, as interviewers might consider it fair game for questioning.
* Non-native English speakers: Get your resume proofread by a native speaker. Avoid including age, marital status, or
  nationality on US applications.

# Additional Tips:

* Be aware of potential language stigmas associated with enterprise languages or being overly language-focused. Some
  companies might view a long list of technologies negatively.
* Certifications can be neutral or even negative depending on the company culture. Consider removing them if you have a
  very lengthy list of technologies.
* If you only know one or two languages, the advice is to broaden your skillset by learning new ones.

#### V Behavioral Questions

# What are behavioral questions?

* Asked to understand your personality, experience, and ease you into the interview.
* How to prepare for behavioral questions?

# Practice your answers:

* Be Specific: Avoid arrogance, use facts and let the interviewer interpret your skills.
* Limit Details: Focus on key points and offer to elaborate if needed.
* Focus on Yourself: Highlight your contributions, not the team's.
* Structure your response: Use the "Nugget First" (briefly summarize your answer) or "SAR" (Situation, Action, Result)
  methods.
* Consider creating a grid to organize your stories using these methods.
* Explore the Action: Break down the "action" part of your story in detail, as this is the most important part.

* Think About What It Says: Identify the personality traits your actions demonstrate (initiative, leadership, teamwork,
  etc.)

# How to answer "Tell me about yourself"

* This is your chance to make a good first impression.
* Use a chronological structure: Briefly mention your current role, educational background (including internships), and
  relevant hobbies (optional).

#### VI Big O

# The Analogy:

* Imagine sending a large file to a friend across the country. Email or FTP might be ideal for small files, but for a
  massive file, physically delivering it could be faster. This highlights the difference between constant-time
  operations (like emailing) and those that grow with data size (like physically delivering the file).

# Big O Time:

* Big O describes the efficiency of algorithms based on their runtime growth as the data size increases.
* It focuses on the dominant term and ignores constants and lower-order terms.

# Common Big O Notations:

* O(1): Constant time (independent of data size)
* O(log N): Logarithmic time (runtime increases slowly with data size)
* O(N): Linear time (runtime increases proportionally with data size)
* O(N log N): Log-linear time (faster than N^2)
* O(N^2): Quadratic time (runtime increases quadratically with data size)
* O(2^N): Exponential time (runtime explodes very quickly with data size)

# Best, Worst, and Expected Case:

* These describe the runtime for specific scenarios (e.g., best case might be O(1) for a sorted array).
* Big O focuses on the upper bound (worst-case) for general analysis.

# Space Complexity:

* Similar to time complexity, it measures the memory required by an algorithm.
* Common examples: O(N) for an array, O(1) for a constant amount of data.

# Key Points:

* Drop constants: O(2N) is considered the same as O(N) for Big O analysis.
* Drop non-dominant terms: O(N + log N) becomes O(N).
* Understand multipart algorithms: Add runtimes for sequential steps and multiply for nested loops.
* Amortized time: Considers the average cost over time for operations with occasional spikes.
* Logarithmic runtimes: Common when the problem space gets halved with each step (e.g., binary search).
* Recursive runtimes: Analyze the call tree depth and branching factor to determine the runtime (e.g., O(2^N) for the
  provided example).
* Remember: Big O is essential for understanding algorithm efficiency and making informed choices when designing or
  selecting algorithms.

#### VII Technical Questions

# Preparation:

* Don't just memorize solutions, practice solving problems yourself.
* Write code on paper to get used to slower coding environments and avoid relying on syntax highlighting or code
  completion.
* Test your code on paper for various scenarios (general cases, base cases, error cases, etc.).
* Practice mock interviews to get comfortable explaining your thought process.

# Knowledge:

* The interview questions focus on data structures, algorithms, and concepts, not specific algorithms for complex
  topics.
* Core knowledge includes Linked Lists, Trees, Tries & Graphs, Stacks & Queues, Heaps, Vectors/Arrays, Hash Tables,
  Breadth-First Search, Depth-First Search, Binary Search, Merge Sort, Quick Sort, Bit Manipulation, Memory (Stack vs.
  Heap), Recursion, Dynamic Programming, and Big O Time & Space complexity.

# Problem-Solving Approach:

* Listen carefully to the problem description and pay attention to details.
* Draw an example to visualize the problem and identify relevant information.
* Start with a brute force solution (a basic algorithm that may not be efficient) and explain its time and space
  complexity.
* Optimize the solution by looking for bottlenecks, unnecessary work, and duplicated work. Techniques include BUD (
  Bottlenecks, Unnecessary work, Duplicated work) and DIY (Do It Yourself - think intuitively about how you'd solve it
  manually).
* Walk through your optimized solution to solidify your understanding before coding.

# Coding:

* Start coding at the top left corner of the whiteboard and avoid line creep (writing code with awkward slant).
* Write beautiful code that is modular, uses error checks, clear variable names, and avoids single-letter variables (
  except for common iterators like i and j).
* Test your code with various test cases (conceptual test, weird-looking code, hot spots, small test cases, special
  cases).
* If you find bugs, analyze why they occurred and fix them carefully.

# Keeping Track of Medians with Heaps

* Describes a method for keeping track of the median element in a stream of numbers using two heaps: a min-heap for the
  smaller half and a max-heap for the larger half.
* This approach allows for quick "rebalancing" by moving elements between heaps when their sizes differ.

# Best Conceivable Runtime (BCR)

* Explains the concept of BCR, which is the theoretically fastest possible runtime for a given problem.
* Knowing the BCR helps determine how much improvement is possible for an algorithm.
* It's important to derive the BCR, not guess it.

# Example: Finding Elements Common to Sorted Arrays

* Illustrates how BCR is used to analyze the runtime of an algorithm.
* Shows a brute-force approach with O(N^2) runtime and an improved O(N log N) solution using binary search.
* Emphasizes that even without sorted data, the same O(N) runtime might be achievable.

# Handling Incorrect Answers in Interviews

* Clarifies that interviews are not about getting every answer perfectly right.
* Evaluates candidates based on the final solution, time taken, help needed, and code clarity.
* Highlights that strong candidates might make mistakes during the interview process.

# Tips for Choosing a Programming Language

* Focuses on languages you're comfortable with, considering factors like:
* Prevalence (interviewer's familiarity)
* Readability (ease of understanding for the interviewer)
* Potential problems (e.g., memory management in C++)
* Verbosity (conciseness of the code)
* Ease of use (language-specific features)

# What Good Coding Looks Like

* Defines good code as having properties like:
* Correctness (handles all expected and unexpected inputs)
* Efficiency (balances time and space complexity)
* Simplicity (written concisely)
* Readability (easy to understand for other developers)
* Maintainability (adaptable to changes)

#### VIII Offer and beyond

# Handling Offers and Rejections

* It's okay to negotiate offers, even if it feels uncomfortable.
* You can decline an offer politely and professionally, focusing on reasons like a startup being a better fit for you
  right now.
* Rejection doesn't mean you're a bad engineer. Many factors can influence an interview outcome.
* Use rejections as an opportunity to learn and improve by asking for feedback (if possible).

# Evaluating an Offer

* Don't just focus on salary. Consider factors like signing bonuses, cost of living, stock options, and long-term career
  development.
* Think about the company culture, team, and your happiness working there.

# Negotiation Tips

* Negotiation can significantly improve your compensation package.
* Have a viable alternative offer (or the willingness to walk away) to strengthen your bargaining position.
* Be specific in your requests (e.g., ask for a certain amount of salary increase).
* Consider asking for non-salary benefits like more equity or signing bonus.
* Negotiation can be done over email if phone calls feel intimidating.

# Beyond the Offer

* Plan your career path. Set goals and milestones to avoid getting stuck in a role that doesn't advance your skills.
* Build strong relationships with colleagues and managers. Networking is crucial for future opportunities.
* Advocate for yourself and communicate your career goals to your manager.
* Keep interviewing (even if not actively looking) to stay sharp and informed about the market.

#### 1 Arrays and strings

#### 2 Linked List

#### 3 Stacks and queues

#### 4 Trees and Graphs

#### 5 Bit Manipulation

#### 6 Math and Logic Puzzles

* Two integers are relatively prime or Coprime when there are no common factors other than 1
* If the two jug sizes are relatively prime, you can measure any value between one and the sum of the jug sizes.
* 1000 poisoned bottles solves with binary representation of every bottle to tests

#### 7 Object-Oriented Design

#### 8 Recursion and Dynamic Programming

#### 9 System Design and Scalability

# Handling the Questions

* Communicate: A key goal of sys�em design questions is to evaluate your ability to communicate. Stay engaged with the
  interviewer. Ask them questions. Be open about the issues of your system.
* Go broad first: Don't dive straight into the algorithm part or get excessively focused on one part.
* Use the whiteboard: Using a whiteboard helps your interviewer follow your proposed design. Get up to the whiteboard in
  the very beginning and use it to draw a picture of what you're proposing.
  Acknowledge interviewer concerns: Your interviewer will likely jump in with concerns. Don't brush them off; validate
  them. Acknowledge the issues your interviewer points out and make changes accordingly.
* Be careful about assumptions: An incorrect assumption can dramatically change the problem. For example, if your system
  produces analytics / statistics for a dataset, it matters whether those analytics must be totally up to date.
* State your assumptions explicitly: When you do make assumptions, state them. This allows your interviewer to correct
  you if you're mistaken, and shows that you at least know what assumptions you're making.
* Estimate when necessary: In many cases, you might not have the data you need. For example, if you're designing a web
  crawler, you might need to estimate how much space it will take to store all the URLs. You can estimate this with
  other data you know.
* Drive: As the candidate, you should stay in the driver's seat. This doesn't mean you don't talk to your interviewer;
  in fact you must talk to your interviewer. However, you should be driving through the question. Ask questions. Be open
  about tradeoffs. Continue to go deeper. Continue to make improvements.
  These questions are largely about the process rather than the ultimate design.

#### 10 Sorting and searching

#### 11 Testing

#### 12 С and C++

# All data members and methods are private by default in C++. One can modify this by introducing keyword public.

#### 13 Java

# Rethrow from catch still calls finally block

#### 14 Databases

# There are explicit and implicit joins in SQL

#### 15 Threads and Locks

#### 16 Moderate

#### 17 Hard

# Selection Rank Algorithm

# Boyer-Moore Majority Voting Algorithm

#### XI Advanced Topics

# The sum of a sequence of power of two is roughly equal to the next value in the sequence.

# Logs of different bases are only off by a constant factor. For this reason, we largely ignore what the base of a log within a big O expression. It doesn't matter since we drop constants anyway.

# A topological sort of a directed graph is a way of ordering the list of nodes such that if (a, b) is an edge in the graph then a will appear before b in the list. If a graph has cycles or is not directed, then there is no topological sort.

# Hashmap collisions and Double Hashing

* You could use a second hash function to determine the probe distance.

Cracking the Coding Interview

#### I The interview process

* Focus on Problem-Solving: These interviews assess your ability to tackle new algorithmic problems.
* Limited Time: Expect to delve into one or two questions within a 45-minute timeframe.
* Communication is Crucial: Think out loud and explain your thought process throughout the interview. Interviewers might
  offer hints, which is normal.
* Subjective Evaluation: A numeric score isn't assigned. Instead, interviewers assess your analytical skills, coding
  abilities, technical knowledge, experience, and cultural fit.
* False Negatives are Acceptable: Companies acknowledge that some good candidates might be rejected, but prioritize
  avoiding false positives (hiring unsuitable candidates).
* Problem-Solving Skills Matter: The ability to solve challenging problems with some guidance indicates strong potential
  and intelligence - valuable assets for companies.
* Data Structures & Algorithms: Understanding these fundamentals is beneficial as many interview problems involve them.
  It demonstrates a solid technical foundation.
* Whiteboard Coding: While not reflecting real-world coding scenarios, whiteboards help focus on the core problem
  without getting bogged down in syntax or boilerplate code. It also encourages communication.
* Not a Universal Approach: This interview style may not be suitable for all companies or roles. Some might prioritize
  experience or specific technology expertise.
* Imperfect but Functional: This process has limitations, but it's a common approach. The goal is to optimize your
  performance within this framework.

#### II Behind the scenes

# General Process:

* Phone Screening: Often the first step, involving basic technical questions and assessing your fit for the company.
* On-Site Interviews: Typically consist of 3-6 interviews with engineers, hiring managers, and potentially teammates.
  These interviews cover various areas like coding, algorithms, system design, behavioral questions, and experience.
* Interview Feedback: After the interviews, your interviewers will provide written feedback that is used to make a
  hiring decision.

# Company Specifics:

* Microsoft: Values passionate individuals with strong technical skills. Interviewers may share feedback within the
  team. You might meet the hiring manager if you perform well.
* Amazon: Emphasizes scalability. "Bar Raiser" interviews exist to maintain a high hiring standard. Interviewers don't
  see each other's feedback until submitted.
* Google: Strong focus on analytical abilities and problem-solving skills. Interviewers don't make the final hiring
  decision; a committee reviews feedback and makes a recommendation.
* Apple: Looks for both technical skills and passion for the company and its products. Interviewers typically don't
  share feedback with each other. Final decisions involve directors and VPs.
* Facebook: Uses a role-based interview system with "Jedi" (behavioral), "Ninja" (algorithms/coding), and "Pirate" (
  system design) interviewers. Interviewers submit individual feedback before discussing your performance.
* Palantir: Interviews for specific teams. Phone interviews and coding assessments are common. On-site interviews cover
  experience, domain knowledge, and design. Interviewers discuss feedback with the hiring manager after your visit.

# Tips:

* Be prepared to discuss your passion for the company and the specific role.
* Practice coding on whiteboards and discussing your thought process.
* Tailor your answers to the specific company and role you are interviewing for.
* Follow up with your recruiter if you haven't heard back within a week.

#### III Special situations

* Experienced Candidates: They might be asked similar questions to recent grads, but interviewers might expect them to
  have a deeper understanding of the concepts being tested. Their performance on system design and architecture
  questions will be evaluated with respect to their experience level.
* Testers and SDETs: They should prepare for core testing problems and practice coding questions like regular
  developers. Additionally, they should practice testing the coding problems they solve and demonstrate strong
  communication skills.
* Product (and Program) Managers: Interviewers will assess their skills in handling ambiguity, customer focus (both
  attitude and technical skills), multi-level communication, passion for technology, and teamwork/leadership.
* Dev Lead and Managers: Strong coding skills are required and they will be assessed on teamwork/leadership,
  prioritization, communication, and "getting things done".
* Startups: The application and interview process can be variable. It's important to network and highlight your ability
  to hit the ground running with the specific technologies the startup uses. Interviewers will assess personality fit,
  skill set, and experience.
* Acquisitions and Acquihires: During the technical due diligence process, the acquirer will interview most or all of
  the startup's employees. These interviews are important and can determine which employees receive offers to join the
  acquirer and can affect the acquisition price.
* For Interviewers: The book advises against asking the exact questions in the book and to focus on medium and hard
  problems with multiple hurdles. Interviewers should avoid "scary" questions and offer positive reinforcement to
  candidates. They should also probe deeper on behavioral questions to understand the candidate's role in past
  situations.

#### IV Before the Interview

# Getting the Right Experience (Before you even start applying)

* Students: Take project-heavy classes, get internships (especially early on), or build personal projects to gain
  practical experience. Focus on relevant projects that showcase your coding skills.
* Professionals: If switching to a dream company: try to shift your work responsibilities towards more coding projects.
  If looking to move to a different role (e.g., testing to dev): use your free time to build projects using relevant
  technologies to showcase your skills and initiative.

# Writing a Great Resume

* Highlight your technical skills and coding experience. Less emphasis on non-technical hobbies.
* Length: Keep it concise (ideally 1 page for less than 10 years experience). Recruiters spend limited time reviewing
  resumes, so prioritize the most impressive aspects.
* Employment History: Only include relevant positions that showcase your skills.
* Bullet Points: Use a strong format: "Accomplished X by implementing Y which led to Z." Quantify results whenever
  possible.
* Projects: Highlight 2-4 most significant projects, including details like languages used, whether it was individual or
  team-based, and if completed for a class or independently (independent projects are generally preferred). Don't
  clutter your resume with too many small projects.
* Programming Languages & Software: Be selective about what you list. Consider the company culture and what's most
  relevant to the role. Don't waste space on basic software like MS Office.
* Languages: List most comfortable languages with your proficiency level (e.g., expert, proficient). Avoid listing
  everything you've ever used, as interviewers might consider it fair game for questioning.
* Non-native English speakers: Get your resume proofread by a native speaker. Avoid including age, marital status, or
  nationality on US applications.

# Additional Tips:

* Be aware of potential language stigmas associated with enterprise languages or being overly language-focused. Some
  companies might view a long list of technologies negatively.
* Certifications can be neutral or even negative depending on the company culture. Consider removing them if you have a
  very lengthy list of technologies.
* If you only know one or two languages, the advice is to broaden your skillset by learning new ones.

#### V Behavioral Questions

# What are behavioral questions?

* Asked to understand your personality, experience, and ease you into the interview.
* How to prepare for behavioral questions?

# Practice your answers:

* Be Specific: Avoid arrogance, use facts and let the interviewer interpret your skills.
* Limit Details: Focus on key points and offer to elaborate if needed.
* Focus on Yourself: Highlight your contributions, not the team's.
* Structure your response: Use the "Nugget First" (briefly summarize your answer) or "SAR" (Situation, Action, Result)
  methods.
* Consider creating a grid to organize your stories using these methods.
* Explore the Action: Break down the "action" part of your story in detail, as this is the most important part.

* Think About What It Says: Identify the personality traits your actions demonstrate (initiative, leadership, teamwork,
  etc.)

# How to answer "Tell me about yourself"

* This is your chance to make a good first impression.
* Use a chronological structure: Briefly mention your current role, educational background (including internships), and
  relevant hobbies (optional).

#### VI Big O

# The Analogy:

* Imagine sending a large file to a friend across the country. Email or FTP might be ideal for small files, but for a
  massive file, physically delivering it could be faster. This highlights the difference between constant-time
  operations (like emailing) and those that grow with data size (like physically delivering the file).

# Big O Time:

* Big O describes the efficiency of algorithms based on their runtime growth as the data size increases.
* It focuses on the dominant term and ignores constants and lower-order terms.

# Common Big O Notations:

* O(1): Constant time (independent of data size)
* O(log N): Logarithmic time (runtime increases slowly with data size)
* O(N): Linear time (runtime increases proportionally with data size)
* O(N log N): Log-linear time (faster than N^2)
* O(N^2): Quadratic time (runtime increases quadratically with data size)
* O(2^N): Exponential time (runtime explodes very quickly with data size)

# Best, Worst, and Expected Case:

* These describe the runtime for specific scenarios (e.g., best case might be O(1) for a sorted array).
* Big O focuses on the upper bound (worst-case) for general analysis.

# Space Complexity:

* Similar to time complexity, it measures the memory required by an algorithm.
* Common examples: O(N) for an array, O(1) for a constant amount of data.

# Key Points:

* Drop constants: O(2N) is considered the same as O(N) for Big O analysis.
* Drop non-dominant terms: O(N + log N) becomes O(N).
* Understand multipart algorithms: Add runtimes for sequential steps and multiply for nested loops.
* Amortized time: Considers the average cost over time for operations with occasional spikes.
* Logarithmic runtimes: Common when the problem space gets halved with each step (e.g., binary search).
* Recursive runtimes: Analyze the call tree depth and branching factor to determine the runtime (e.g., O(2^N) for the
  provided example).
* Remember: Big O is essential for understanding algorithm efficiency and making informed choices when designing or
  selecting algorithms.

#### VII Technical Questions

